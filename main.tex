\documentclass[letterpaper]{article}
% DO NOT CHANGE THIS
\usepackage[]{aaai25} % DO NOT CHANGE THIS
\usepackage{times} % DO NOT CHANGE THIS
\usepackage{helvet} % DO NOT CHANGE THIS
\usepackage{courier} % DO NOT CHANGE THIS
\usepackage[hyphens]{url} % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm} % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\usepackage{natbib} % DO NOT CHANGE THIS
\usepackage{caption} % DO NOT CHANGE THIS
\frenchspacing % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in} % DO NOT CHANGE THISvb
\setlength{\pdfpageheight}{11in} % DO NOT CHANGE THIS
%
% Keep the \pdfinfo as shown here. Thereâ€™s no need
% for you to add the /Title and /Author tags.
\pdfinfo{
/TemplateVersion (2025.1)
}



\usepackage{amsmath,amsfonts,amssymb}
\usepackage{booktabs}
\usepackage{nicematrix}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{caption}
\usepackage{subcaption}

\newcommand{\ket}[1]{|#1 \rangle}
%% Section numbering
\setcounter{secnumdepth}{2}


\title{Efficient Simulation of Proto-Quipper Programs}

\author{Ian Turner\textsuperscript{\rm 1}
}
\affiliations{

\textsuperscript{\rm 1}Department of Computer Science and
Engineering, University of South Carolina, Columbia, South Carolina, USA
}


\begin{document}

\maketitle



\begin{abstract}
    The Proto-Quipper language allows for high-level specification
    of quantum algorithms in a functional paradigm similar to Haskell.
    So far, the execution of Proto-Quipper programs has been confined
    to its own custom simulator (written in Haskell),
    with no ability to run on third-party
    simulators or real quantum hardware.
    This paper discusses efforts to integrate third-party locally-run
    simulators such as those developed by Google (Cirq) and IBM (Qiskit),
    as well as possible future efforts to enable execution of
    Proto-Quipper programs on cloud simulators and even 
    real quantum processing units (QPUs).
\end{abstract}



\section{Introduction}


\subsection{Quantum Programming Languages}

Quantum programming languages allow programers to design quantum algorithms at varying levels of abstraction.
`Low-level' languages like Cirq \cite{cirq}, Qiskit \cite{qiskit}, and OpenQASM \cite{cross2022openqasm} allow for
fine-grained control over circuit construction and execution, while
`high-level' languages such as Silq \cite{bichsel2020silq}, Q\# \cite{svore2018q}, Quipper \cite{green2013quipper},
 and Proto-Quipper \cite{fu2023proto}
allow for more complex circuits to be generated by using programming constructs like loops, recursion, and dynamic
qubit allocation.


\subsection{Proto-Quipper with Dynamic Lifting}

Proto-Quipper is a family of functional quantum programming languages designed to give a formal foundation to Quipper.
Proto-Quipper contains two runtimes; circuit generation and circuit execution.
Variables whose values are determined during circuit generation time are called \textit{parameters}, while variables
that are determined during circuit execution time are called \textit{states}.
Dynamic lifting allows for state variables to be `lifted' to parameters variables.
This can be used to lift circuit measurement results from the circuit execution runtime back into the circuit
generation runtime in order to modify the generation of the next circuit.
This allows for quantum and classical instructions to be interleaved seamlessly.

Proto-Quipper also enforces static typing, which checks
if a circuit generating program is well-typed, ensuring the generated quantum circuit is well-formed.
The types \textbf{Qubit} and \textbf{Bit} are considered \textit{linear resource}, meaning they cannot be duplicated
or discarded.
This prevents runtime/logical errors that can occur in low-level languages such as attempting to duplicate a qubit
or discarding a qubit without measuring it.


\subsection{Simulating Proto-Quipper Programs}

\begin{figure}[!ht]
\centering
\resizebox{0.4\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw [ rounded corners = 4.8] (6.25,15) rectangle  node {\LARGE Client} (10.25,10.25);
\draw [ rounded corners = 4.8] (16.25,15) rectangle  node {\LARGE Server} (20.25,10.25);
\draw [->, >=Stealth] (10.25,14) -- (16.25,14);
\draw [->, >=Stealth] (16.25,11.5) -- (10.25,11.5);
\node [font=\LARGE] at (13.25,14.5) {Commands};
\node [font=\LARGE] at (13.25,12) {Dynamic Lifting};
%%\draw [ rounded corners = 4.8] (16.5,11.5) rectangle  node {\normalsize Internal Quantum State} (20,10.5);
\end{circuitikz}
}%

\caption{Proto-Quipper simulation architecture}
\label{fig:sim_diagram}
\end{figure}


Proto-Quipper programs are simulated with a client-server architecture.
The Proto-Quipper interpreter evaluates high-level code into low-level quantum
instructions in the server language, called QServer, which is an assembly-like language
similar to OpenQASM.
The QServer instructions are then sent over a network socket,
and each instruction is executed by the server sequentially.
The server sends back measurement results only when it receives a dynamic lifting command.
This process is shown in Figure \ref{fig:sim_diagram}.



\section{Integrating Third-Party Simulators}


\begin{figure*}[!ht]
\centering
\resizebox{0.9\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw [ rounded corners = 4.8, align=left] (6.25,15) rectangle  node {Proto-Quipper \\ Interpreter} (10.25,10.25);
\draw [ rounded corners = 4.8] (16.25,15) rectangle  node {\LARGE Server} (20.25,10.25);
\draw [->, >=Stealth] (16.25,11.5) -- (10.25,11.5);
\node [font=\LARGE] at (13.25,15) {Commands};
\node [font=\LARGE] at (13.25,12) {Dynamic Lifting};
\draw [ rounded corners = 4.8] (16.5,11.5) rectangle  node {\normalsize Internal Quantum State} (20,10.5);


\draw [ rounded corners = 4.8] (1,13.25) rectangle  node {\small Proto-Quipper source code} (5,12);
\draw [->, >=Stealth] (5,12.75) -- (6.25,12.75);
\draw [ rounded corners = 4.8] (21.25,14) rectangle  node {\large OpenQASM} (24.25,12.75);
\draw [->, >=Stealth] (20.25,13.5) -- (21.25,13.5);
\draw [ rounded corners = 4.8] (25.75,14) rectangle  node {\large Cirq} (28.5,12.75);
\draw [ rounded corners = 4.8] (25.75,12.25) rectangle  node {\large Qiskit} (28.5,11);
\draw [->, >=Stealth] (24.25,13.5) -- (25.75,13.5);
\draw [->, >=Stealth] (24.25,13.25) -- (25.75,11.75);
\draw [ rounded corners = 4.8] (11.5,14.5) rectangle  node {\large QServer language} (15,13.25);
\draw [->, >=Stealth] (10.25,14) -- (11.5,14);
\draw [->, >=Stealth] (15,14) -- (16.25,14);
\draw [ rounded corners = 4.8] (21.25,12.25) rectangle  node {\large Results} (24.25,11);
\draw [->, >=Stealth] (21.25,11.75) -- (20.25,11.75);
\draw [->, >=Stealth] (25.75,13.25) -- (24.25,11.75);
\draw [->, >=Stealth] (25.75,11.5) -- (24.25,11.5);
\node [font=\scriptsize] at (21.15,10.6) {Update States};
\end{circuitikz}
}%

\caption{Full OpenQASM-based simulation architecture}
\label{fig:full_sim_diagram}
\end{figure*}


\subsection{Available Simulators}

Dozens of state-of-the-art quantum computing simulation programs exist currently \cite{jamadagni2024benchmarking}.
They employ a variety of different simulation methods, including statevector simulation, tensor networks,
decision trees, etc.
For this project, we chose to work with statevector simulators, which model quantum computation using matrix-vector
multiplication.
We integrated the simulation capabilities of the Python-based quantum computing libraries Cirq and Qiskit, given that
they are the most commonly used and extensively developed libraries for quantum computing,
and both have multiple state-of-the-art simulation methods.

In Qiskit and Cirq, the programs that
generate quantum circuits are usually structured
by the following: they start with an array of qubits and bits
all initialized to the $\ket{0}$ state, then we apply a series of in-place operations on those qubits and bits, and then (usually)
measuring the entire qubit array at the end and returning the final qubit and bit states.
The operations applied can be either unitary quantum gates or measurement gates.
There is some support for higher-level programming constructs such as `if' and `while' statements,
where operations can be conditioned on previous measurement outcomes, which is called \textit{dynamic circuits} in Qiskit. 
But these features are still experimental and are quite limited, so we do not use them in this project.


\subsection{Integration with Proto-Quipper}

The main challenges of integrating Cirq and Qiskit into the Proto-Quipper simulation infrastructure are
(1) Cirq and Qiskit do not allow dynamic qubit allocation; meaning ancilla qubits must be allocated during circuit generation,
(2) since Cirq and Qiskit both use the quantum circuit model, a circuit object must be constructed for every simulation,
even if that `circuit' is only a single gate, and (3) in Proto-Quipper, measurement operations `consume' a qubit
and convert it into a bit, while in Cirq and Qiskit measurements simply collapse the qubit into a classical state,
and copy the measurement result onto a separate bit register.

In order to integrate Cirq and Qiskit with Proto-Quipper, we must translate the QServer language
generated by the Proto-Quipper interpreter to the quantum circuit objects of the two libraries.
We chose to use OpenQASM as an intermediate representation, since both Cirq and Qiskit have OpenQASM loading functions,
which transform OpenQASM code into the circuit objects.
The QServer language is very similar to OpenQASM in its function and syntax, making translation
between the two very simple.
A diagram of the full OpenQASM simulation architecture is pictured in Figure \ref{fig:full_sim_diagram}.


\subsection{Converting to OpenQASM}

\begin{figure}[!ht]
\centering
\resizebox{0.4\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw  (6.75,19.25) rectangle  node {\LARGE $|\psi\rangle$} (8.75,17.25);
\draw [short] (4.75,19) -- (6.75,19);
\draw [short] (4.75,18.25) -- (6.75,18.25);
\draw [short] (4.75,17.5) -- (6.75,17.5);
\node [font=\Large] at (4.25,19) {$|0\rangle$};
\node [font=\Large] at (4.25,18.25) {$|0\rangle$};
\node [font=\Large] at (4.25,17.5) {$|0\rangle$};
\draw [short] (8.75,19) -- (10.75,19);
\draw [short] (8.75,18.25) -- (10.75,18.25);
\draw [short] (8.75,17.5) -- (10.75,17.5);
\draw [short] (4.75,19.75) -- (10.75,19.75);
\node [font=\Large] at (4.25,19.75) {$|0\rangle$};
\node [font=\Large] at (11.75,18.5) {$|0\rangle \otimes |\psi\rangle$};
\end{circuitikz}
}%

\caption{Example of new qubit initialization in state $|0\rangle$ with existing state $|\psi\rangle$}
\label{fig:qubit_init}
\end{figure}

The QServer language contains three types of quantum operations: qubit initialization, unitary gates, and qubit measurement.
More importantly, it also has the `read' instruction, which lifts a bit from the server internal state back into the interpreter environment
to be used in further circuit generation.
When the server receives a read instruction, it must pause simulation and hold the current simulation state in memory,
send the measurement result back to the client, and wait for further instructions to continue the simulation.

\paragraph{Qubit Initialization}

Qubits can be initialized into either the $|0\rangle$ or the $|1\rangle$ states.
If the simulation currently has the state $|\psi\rangle$, then when a new qubit
is added in state $|0\rangle$, the new simulation state will be $|0\rangle \otimes |\psi\rangle$.
This is pictured in Figure \ref{fig:qubit_init}, where the box indicates state preparation of the
statevector $|\psi\rangle$ on the input qubits.
The process is the same for initializing a qubit in the 1 state, except an X gate is applied
to the initialized qubit, and the resulting state is $|1\rangle \otimes |\psi\rangle$.

\paragraph{Unitary Gates}

\begin{figure}[!ht]
\centering
\resizebox{0.4\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\large]
\draw  (6.75,19.25) rectangle  node {\LARGE $|\psi\rangle$} (8.75,17.25);
\draw [short] (6.25,19) -- (6.75,19);
\draw [short] (6.25,18.25) -- (6.75,18.25);
\draw [short] (6.25,17.5) -- (6.75,17.5);
\node [font=\Large] at (5.75,19) {$|0\rangle$};
\node [font=\Large] at (5.75,18.25) {$|0\rangle$};
\node [font=\Large] at (5.75,17.5) {$|0\rangle$};
\draw [short] (8.75,19) -- (10.5,19);
\draw [short] (8.75,18.25) -- (12.75,18.25);
\draw [short] (8.75,17.5) -- (12.75,17.5);
\node [font=\LARGE] at (13.5,18.25) {$|\psi'\rangle$};
\draw  (10.5,19.25) rectangle  node {\large H} (11,18.75);
\draw [short] (11,19) -- (12.75,19);
\end{circuitikz}
}%

\caption{Application of a unitary H gate on qubit 1 of state $|\psi\rangle$ to produce updated state $|\psi'\rangle$}
\label{fig:unitary_gate}
\end{figure}

Unitary gates can be applied in a similar manner to initialization.
The current simulation state $|\psi\rangle$ is passed in using a state preparation gate,
and unitary gates are applied to the qubits.
The updated state $|\psi'\rangle$ is then extracted from the simulation results as a statevector,
and stored in memory for use in future computations.
An example of this is pictured in Figure \ref{fig:unitary_gate}.


\paragraph{Measurements}

Measurements can be performed directly on the statevector without creating circuit objects.
Both Qiskit and Cirq provide built-in functions for measurement, which take in a statevector
and a qubit index and return the collapsed statevector and measurement result.
Since measurements in Proto-Quipper consume the qubit, we must also remove the measured
qubit from the updated statevector returned from the measure function.
This can be done by manual manipulations of the statevector using numpy.


\subsection{Instruction Queuing}

\begin{figure}[!ht]
\centering
\resizebox{0.4\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw  (7.75,14.5) rectangle  node {\LARGE $|\psi\rangle$} (9,13.25);
\draw [short] (7.25,14.25) -- (7.75,14.25);
\draw [short] (7.25,13.5) -- (7.75,13.5);
\node [font=\Large] at (6.75,14.25) {$|0\rangle$};
\node [font=\Large] at (6.75,13.5) {$|0\rangle$};
\node [font=\LARGE] at (13.5,14.5) {$|\psi'\rangle$};
\draw  (9.5,14.5) rectangle  node {\large H} (10,14);
\draw [short] (9,14.25) -- (9.5,14.25);
\draw [short] (9,13.5) -- (10.25,13.5);
\node [font=\Large] at (6.75,15.75) {$|0\rangle$};
\node [font=\Large] at (6.75,15) {$|0\rangle$};
\draw [short] (7.25,15) -- (12.75,15);
\draw [short] (7.25,15.75) -- (12.75,15.75);
\draw  (10.25,13.75) rectangle  node {\large S} (10.75,13.25);
\node [font=\LARGE] at (9.75,13.75) {};
\draw [short] (10,14.25) -- (12.75,14.25);
\draw [short] (10.75,13.5) -- (12.75,13.5);
\draw [short] (11.25,15.875) -- (11.25,14.15);
\draw [ fill={rgb,255:red,0; green,0; blue,0} ] (11.25,14.25) circle (0.1cm);
\draw  (11.25,15.75) circle (0.125cm);
\draw [short] (12.25,15.1) -- (12.25,13.375);
\draw [ fill={rgb,255:red,0; green,0; blue,0} ] (12.25,15) circle (0.1cm);
\draw  (12.25,13.5) circle (0.125cm);
\end{circuitikz}
}%

\caption{Queued circuit with initialization of a statevector $|\psi\rangle$ on qubits 3 and 4,
\label{fig:queued_circ}
initialization of qubits 1 and 2 in the $|0\rangle$ state, and several queued unitary gates,
resulting in an updated state $|\psi'\rangle$}
\end{figure}


Given the fact that the server only sends back results when a read command is received, instructions need not be evaluated
until their results are required by the client.
This fact allows us to keep instructions in a queue, and only evaluate the accumulated
circuit once a measurement command is received.
This approach has several advantages.
First, the statevector of the previous computations only has to be prepared once, at the beginning of the
queued circuit, instead of between each instruction.
Second, it allows the simulator server to take advantage of optimizations in the Cirq and Qiskit simulators, which rely
on circuit re-writing and gate fusion \cite{elsman2025gate}.
An example of a queued circuit is pictured in Figure \ref{fig:queued_circ}.


\section{Benchmark Results}

In order to evaluate the simulator we construct a series of benchmark programs in Proto-Quipper.
These benchmarks include the quantum Fourier transform (QFT), several different implementations of binary adders,
and the MaxCut QAOA algorithm \cite{farhi2014quantum}.
We compare the queued and non-queued (normal) versions of the updated server against the original Haskell-based server.
We also compile the benchmark circuits to OpenQASM and run them directly on the Cirq and Qiskit simulators using Python.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.4\textwidth]{{ ./images/qft.png }}
\caption{Simulation time of QFT for all simulation methods}
\label{fig:qft}
\end{figure}

\paragraph{Quantum Fourier Transform} The results for QFT (Figure \ref{fig:qft}) show that the queued versions of the Cirq and
Qiskit simulator significantly outperform
the original Haskell simulator as the number of qubits increases.
The Haskell simulator crashes when trying to simulate more than 20 qubits, while the Qiskit and Cirq simulators are able
to simulate 28 qubits.
They also show that while there is some overhead associated with the interaction of the Proto-Quipper interpreter with the server,
this overhead is almost constant as the circuit increases in size, and the simulation time of the server almost converges to the
simulation time of the bare simulator at around 25 qubits.


\paragraph{Binary Adders}


\begin{figure*}[!ht]
\begin{subfigure}{0.32\textwidth}
    \centering
    \includegraphics[width=\linewidth]{{ ./images/qftadder.png }}
    \caption{QFT adder}
\end{subfigure}
\hfill
\begin{subfigure}{0.32\textwidth}
    \centering
    \includegraphics[width=\linewidth]{{ ./images/cuccaro.png }}
    \caption{Cuccaro adder} 
\end{subfigure}
\hfill
\begin{subfigure}{0.32\textwidth}
    \centering
    \includegraphics[width=\linewidth]{{ ./images/gidney.png }}
    \caption{Gidney adder} 
\end{subfigure}
\caption{Simulation results for binary adders}
\label{fig:adder_results}
\end{figure*}


The Cirq and Qiskit simulators perform significantly worse than the Haskell simulator for binary adders,
as shown in Figure \ref{fig:adder_results}.
This is likely due to how the Haskell simulator stores quantum states.
The Haskell simulator stores the statevector as a map of bitstrings to amplitudes.
For example, the state $(|00\rangle + |11\rangle)/\sqrt{2}$ is stored as $[(00, 1/\sqrt{2}), (11, 1/\sqrt{2})]$.
This means that if the statevector is not in a superposition, then the Haskell representation needs
only one complex number to describe it.
This is in contrast to the Cirq and Qiskit simulators, which store the entire statevector, with $2^n$ entries (for $n$ qubits).
As a result, the Haskell simulator will almost always outperform the Cirq and Qiskit simulators on circuits that involve
mostly classical operations, such as adders.
Of course, useful quantum algorithms will inevitably contain many non-classical operations, resulting in a large degree
of superposition and entanglement, so in practice this limitation is largely irrelevant.


\begin{figure}[!ht]
\centering
\includegraphics[width=0.4\textwidth]{{ ./images/maxcut.png }}
\caption{MaxCut QAOA}
\label{fig:maxcut}
\end{figure}


\paragraph{MaxCut QAOA}

The maxcut quantum approximate optimization algorithm finds the partition of a graph into two graphs such that the
number of edges between the partitions (which are `cut') is maximized.
This circuit is an ideal candidate for a simulation benchmark since it is one of the few algorithms that may provide
quantum advantage in the near term, meaning quantum computers may soon be able to out-perform classical computers on this task.
Because of this, it has been the subject of much study and development, which requires accurate and fast simulation.
The results in Figure \ref{fig:maxcut} show that the Cirq and Qiskit simulators dramatically outperform the Haskell
simulator on this task.
This is not surprising, since the maxcut circuit creates states with high levels of superposition and entanglement.


\section{Related work}

Other works have explored converting high-level quantum programming languages to OpenQASM in order to execute them more efficiently.
LinguaQuanta \cite{wesley2024linguaquanta} converts Quipper circuit objects to OpenQASM,
but only supports `boxed' circuits (which have no dynamic lifting instructions).
The Q\# language is a similar high-level language,
but is simulated by first compiling to quantum intermediate representation (QIR) \cite{stade2024towards},
a low-level quantum-classical hybrid specification based on LLVM.
Silq, another high-level language, runs on its own custom simulator,
and cannot be run on third-party simulators or any real quantum hardware.


\section{Conclusion and Future Work}

This work presents an approach for simulating a high-level quantum programming language on state-of-the-art third-party
quantum simulators.
This approach extends the number of qubits able to be simulated compared to the existing Proto-Quipper simulator,
but has some downsides when compared to the original simulator, and is still significantly limited by memory constraints.
Future work could include integrating more advanced simulators such as tensor network simulators,
which can scale simulations to several hundred qubits by exploiting approximation and low degrees of entanglement.
Future work could also include compiling Proto-Quipper programs directly to a low-level intermediate format.


\bibliography{refs.bib}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
