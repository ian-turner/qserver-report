%\documentclass[a4paper,11pt]{article}
%\usepackage[margin=0.5in,bottom=1in]{geometry}
%\usepackage{graphicx} % Required for inserting images
%\usepackage{amsmath}
%\usepackage{hyperref}
%\usepackage{authblk}
%\usepackage{titling}

\documentclass[letterpaper]{article}
% DO NOT CHANGE THIS
\usepackage[]{aaai25} % DO NOT CHANGE THIS
\usepackage{times} % DO NOT CHANGE THIS
\usepackage{helvet} % DO NOT CHANGE THIS
\usepackage{courier} % DO NOT CHANGE THIS
\usepackage[hyphens]{url} % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm} % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\usepackage{natbib} % DO NOT CHANGE THIS
\usepackage{caption} % DO NOT CHANGE THIS
\frenchspacing % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in} % DO NOT CHANGE THISvb
\setlength{\pdfpageheight}{11in} % DO NOT CHANGE THIS
%
% Keep the \pdfinfo as shown here. Thereâ€™s no need
% for you to add the /Title and /Author tags.
\pdfinfo{
/TemplateVersion (2025.1)
}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{booktabs}
\usepackage{nicematrix}
%% Section numbering
% \setcounter{secnumdepth}{2}


\title{Efficient Simulation of Proto-Quipper Programs}

\author{Ian Turner\textsuperscript{\rm 1}
}
\affiliations{

\textsuperscript{\rm 1}Department of Computer Science and
Engineering, University of South Carolina, Columbia, South Carolina, USA
}


\begin{document}

%\title{
%\textbf{
%Efficient Simulation of Proto-Quipper Programs
%}
%}
%\author{Ian Turner, University of South Carolina}
%\predate{}
%\date{}
%\postdate{}
\maketitle



\begin{abstract}
    The Proto-Quipper language allows for high-level specification
    of quantum algorithms in a functional paradigm similar to Haskell.
    So far, the execution of Proto-Quipper programs has been confined
    to its own custom simulator (written in Haskell),
    with no ability to run on third-party
    simulators or real quantum hardware.
    This paper discusses efforts to integrate third-party locally-run
    simulators such as those developed by Google (Cirq) and IBM (Qiskit),
    as well as possible future efforts to enable execution of
    Proto-Quipper programs on cloud simulators and even 
    real quantum processing units (QPUs).
%    We start by describing the technical requirements of Proto-Quipper
%    program simulation,
%    as well as the differences from other quantum programming
%    paradigms that make interoperability between Proto-Quipper and
%    rest of the quantum ecosystem difficult.
%    We then explain our specific implementation of a new simulator
%    architecture that allows for Proto-Quipper programs to be run
%    on third-party simulators, and benchmark our implementation
%    against the existing Haskell-based simulator on several
%    quantum computing tasks.
%    Finally, we discuss the shortcomings of our approach and how future
%    work can overcome these, including the current lack of ability to
%    run Proto-Quipper programs on currently available QPUs.
\end{abstract}



\section{Introduction}



\subsection{Quantum Programming Languages}

%Quantum programming languages allow programmers to design quantum algorithms at varying levels of abstraction,
%without having to specify the machine instructions required to implement the components of those algorithms.
%These languages can broadly be broken down into `high-level' and `low-level'.
%Low-level languages, such Cirq \cite{cirq}, Qiskit \cite{qiskit}, and OpenQASM \cite{cross2022openqasm}
%can essentially be described as `circuit description languages', where programs are built as a series of unitary
%gate applications to a set of input qubits, as well as mid-circuit measurement operations and gates conditioned on
%those measurement results.
%These languages, similar to assembly languages in classical computing, provide fine-grained control over hardware execution,
%but lack flexibility.
%Although these languages have recently started to add more higher-level programming constructs to their syntax
%(such as for loops and classical variables), they still remain quite limited, mainly in their lack of ability
%to dynamically allocate and de-allocate qubits `on the fly', meaning that the number of qubits a computation uses
%must be known at compile time, and each gate must be mapped to a specific qubit index.
%Cirq and Qiskit are also embedded languages with Python that lack their own syntax/interpreter and rely greatly
%on Python programming constructs to extend their basic capabilities.


%In contrast, high-level languages, such as Silq \cite{bichsel2020silq}, Q\# \cite{QSharpDocs},
%and Proto-Quipper \cite{fu2023proto}, are much more flexible
%and extensible, and are designed to generalize to any quantum hardware.
%They allow for dynamic allocation and de-allocation of qubits, meaning circuits with `ancillas' (qubits that are allocated during
%a circuit, used for computation, then returned to the zero state and de-allocated at the end of the circuit)
%can be programmed easily and directly, without the programmer having to worry about qubit memory allocation at compile time.
%They also allow for higher-level classical programming constructs like functions and loops, as well as quantum
%programming constructs like uncomputation and reversing.

Quantum programming languages allow programers to design quantum algorithms at varying levels of abstraction.
`Low-level' languages like Cirq \cite{cirq}, Qiskit \cite{qiskit}, and OpenQASM \cite{cross2022openqasm} allow for
fine-grained control over circuit construction and execution, while
`high-level' languages such as Silq \cite{bichsel2020silq}, Q\# \cite{svore2018q}, Quipper \cite{green2013quipper},
 and Proto-Quipper \cite{fu2023proto}
allow for more complex circuits to be generated by using programming constructs like loops, recursion, and dynamic
qubit allocation.




\subsection{Proto-Quipper with Dynamic Lifting}

Proto-Quipper is a family of functional quantum programming languages designed to give a formal foundation to Quipper.
In contrast to low-level languages, Proto-Quipper contains two runtimes; circuit generation and circuit execution.
Variables whose values are defined during circuit generation time are called \textit{parameters}, while variables
that are defined during circuit execution time are called \textit{states}.
Dynamic lifting allows for state variables to be `lifted' to parameters variables.
This can be used to lift circuit measurement results from the circuit execution runtime back into the circuit
generation runtime in order to modify the generation of the next circuit.
This allows for quantum and classical instructions to be interleaved seamlessly.

Proto-Quipper also enforces a typing system, which ensures program correctness through type checking.
The types \textbf{Qubit} and \textbf{Bit} are considered \textit{linear}, meaning they cannot be duplicated
or discarded.
This prevents runtime/logic errors that can occur in low-level languages such as attempting to duplicate a qubit
or discarding a qubit without measuring it.




\subsection{Simulating Quantum Circuits}

An $N$-qubit quantum system can be described by a unit vector in a complex vector space of size $2^N$.
In the case of one qubit, all possible states can be described as
\begin{equation}
|\psi\rangle = \alpha \begin{bmatrix} 1 \\ 0 \end{bmatrix}
+ \beta \begin{bmatrix} 0 \\ 1 \end{bmatrix} = \alpha|0\rangle + \beta|1\rangle
\end{equation}
where $\alpha, \beta \in \mathbb{C}$ and $|\alpha|^2+|\beta|^2=1$ \cite{nielsen2001quantum}.
Quantum gates can be desribed as unitary matrices that transform quantum states.
For example, the $X$ gate swaps $|0\rangle$ states with $|1\rangle$ states;
\begin{equation}
X|\psi\rangle = X(\alpha|0\rangle + \beta|1\rangle) = \beta|0\rangle + \alpha|1\rangle,
\end{equation}
and can be written as
\begin{equation}
X := \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}.
\end{equation}

Multiple-qubit systems can be constructed using the tensor product.
The tensor product is a binary operator on matrices and vectors with the following formula
\begin{equation}
v \otimes w :=
\left[\begin{array}{cccc}
v_{1} w_{1} & v_{1} w_{2} & \cdots & v_{1} w_{m} \\
v_{2} w_{1} & v_{2} w_{2} & \cdots & v_{2} w_{m} \\
\vdots & \vdots & \ddots & \vdots \\
v_{n} w_{1} & v_{n} w_{2} & \cdots & v_{n} w_{m}
\end{array}\right]
\end{equation}
For example, the two qubit state $|01\rangle$ can be constructed as
\begin{equation}
|01\rangle = |0\rangle \otimes |1\rangle = \begin{bmatrix} 1 \\ 0 \end{bmatrix} \otimes \begin{bmatrix} 0 \\ 1 \end{bmatrix}
= \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix},
\end{equation}
and applying the $X$ gate to the second qubit in a two-qubit system can be described as
\begin{equation}
X_2 = I \otimes X =
\begin{bmatrix}
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
\end{bmatrix}.
\end{equation}

Aside from unitary gate operations, qubits can also be measured to collapse their state into either 0 or 1.
Measurement on a qubit $|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$
will yield 0 with probability $|\alpha|^2$ and 1 with probability $|\beta|^2$.

The key challenge in simulating quantum circuits is that the amount of memory required to represent and manipulate a 
quantum state grows exponentially with the number of qubits.
This means that while directly simulating a few qubits is relatively trivial for a classical computer,
simulating more than 30 qubits is nearly impossible without resorting to
complex, domain-specific optimization techniques and/or using powerful supercomputers.


\subsection{Simulating Proto-Quipper Programs}

Proto-Quipper programs are simulated with a client-server architecture.
The Proto-Quipper interpreter parses high-level code into quantum
instructions in the server language, which is an assembly-like language
similar to OpenQASM.
The server language instructions are then sent over a network socket,
and each instruction is executed by the server sequentially.
The server sends back measurement results when it receives a `read' command.


\section{Integrating Third-Party Simulators}



\subsection{Idea}

\subsection{Implementation}

\section{Benchmark Results}

\section{Related work}

\section{Conclusion and Future Work}

\paragraph{Investigating MPS}
\paragraph{Dynamic lifting to OpenQasm3}
\paragraph{Dynamic lifting to QIR}



\bibliography{refs.bib}

\end{document}

