\documentclass[runningheads]{llncs}
\usepackage[T1]{fontenc}
\usepackage{graphicx}


\usepackage{amsmath,amsfonts,amssymb}
\usepackage{booktabs}
\usepackage{nicematrix}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{hyperref}

%% Command for ket vector formatting
\newcommand{\ket}[1]{|#1 \rangle}

%% Section numbering
\setcounter{secnumdepth}{2}


\title{Efficient Simulation of Proto-Quipper Programs}
\author{Ian Turner, Peng Fu}
\institute{Department of Computer Science and Engineering, University of South Carolina, Columbia, South Carolina, USA}


\begin{document}

\maketitle



\begin{abstract}
    The Proto-Quipper language allows for high-level type-safe specification
    of quantum algorithms in a functional paradigm.
    So far, the execution of Proto-Quipper programs has been confined
    to its own custom simulator written in Haskell,
    with no ability to run on third-party simulators or real quantum hardware.
    This is because the available third-party simulators
    lack native support of \textit{dynamic lifting}. Dynamic lifting is a feature in Quipper
    and Proto-Quipper where measurement results can be fed back into the
    circuit generation environment in real time to generate the next
    portion of the circuit.

    In this paper, we extend the existing Proto-Quipper simulation architecture with
    state-of-the-art quantum simulators from Cirq and Qiskit.  
    Although these simulators do not directly support dynamic lifting,
    we are able to slightly extend
    the simulators' capabilities to enable running Proto-Quipper
    programs that use dynamic lifting.
    We also build an OpenQasm converter for Proto-Quipper circuits,
    which enable the circuits to be ran on existing quantum processors
    and simulators.
    Finally, we optimize our simulator using instruction queuing and
    show they significantly outperform
    the existing custom simulator on our benchmarks.
    
\end{abstract}



\section{Introduction}

Quantum programming languages allow programers to design quantum algorithms at varying levels of abstraction.
For example, OpenQASM \cite{cross2022openqasm} is designed as an intermediate representation for describing quantum circuits.  
Whereas in Cirq \cite{cirq} and Qiskit \cite{qiskit}, programmers are able to use all of Python's libraries and functionality to construct
quantum circuits. 
For even higher-level languages, such as Silq \cite{bichsel2020silq}, Q\# \cite{svore2018q}, Quipper \cite{green2013quipper},
and Proto-Quipper \cite{fu2023proto}, they provide advance features such as automatic uncomputation, type checking, dynamic
lifting and type-safe circuit reversing and control.

Proto-Quipper is a family of functional quantum programming languages designed to give a formal foundation to Quipper
\cite{fu2023proto,fu2024proto}.
Proto-Quipper contains two runtimes: circuit generation time and circuit execution time.
Variables whose values are determined during circuit generation time are called \textit{parameters}, while variables
that are determined during circuit execution time are called \textit{states}.
\textit{Dynamic lifting} allows for state variables to be `lifted' to parameters variables.
The circuit measurement results from the circuit execution runtime can be used 
in the circuit
generation time to inform the generation of the next circuit.
Thus dynamic lifting allows the two runtimes to be interleaved seamlessly.

While dynamic lifting enable programmers to create much more complex circuits than
would be feasible to directly implement in Cirq or Qiskit, it is an expensive operation, as it
requires control to pass from circuit execution time back to circuit generation time. This requires
the real-time quantum computer to put all of its active qubits into long-term storage while spending
an indeterminate amount of time awaiting further instructions from the classical computer in
charge of circuit generation \cite{fu2023proto}.
Moreover, dynamic lifting increases the
complexity of the simulation of such programs, since static circuit objects cannot be created,
and communication between the simulator and language interpreter is needed during the simulation.
So far, no work has attempted to allow direct simulation of dynamic lifting in Quipper or Proto-Quipper on third-party simulators.
In this work, we enable Proto-Quipper programs to
be run on state-of-the-art quantum simulators.
In particular, we build a converter from Proto-Quipper circuits to OpenQASM,
and an interpreter that can run Proto-Quipper programs that use dynamic lifting
by converting them to OpenQASM piece-by-piece on the fly.



\subsection{Simulating Proto-Quipper Programs}

\begin{figure}
\centering
\resizebox{0.5\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw [ rounded corners = 4.8] (6.25,15) rectangle  node {\LARGE Client} (10.25,10.25);
\draw [ rounded corners = 4.8] (16.25,15) rectangle  node {\LARGE Server} (20.25,10.25);
\draw [->, >=Stealth] (10.25,14) -- (16.25,14);
\draw [->, >=Stealth] (16.25,11.5) -- (10.25,11.5);
\node [font=\LARGE] at (13.25,14.5) {Commands};
\node [font=\LARGE] at (13.25,12) {Dynamic Lifting};
%%\draw [ rounded corners = 4.8] (16.5,11.5) rectangle  node {\normalsize Internal Quantum State} (20,10.5);
\end{circuitikz}
}%

\caption{Proto-Quipper simulation architecture}
\label{fig:sim_diagram}
\end{figure}




Proto-Quipper programs are simulated with a client-server architecture as illustrated
in Figure \ref{fig:sim_diagram}.
The client is the Proto-Quipper interpreter, and the server is
a simulator. 
The client evaluates Proto-Quipper programs, produces a sequence of low-level quantum
instructions for the server. This low-level assembly-like language for the server is called QServer in Proto-Quipper-Dyn's implementation \cite{fu2023proto}. The QServer
language is very similar to OpenQasm 2 \cite{cross2017}, the main difference is that QServer
includes a read command
that reads the results of the measurements.
The QServer instructions can be sent to the server over a network socket,
and each instruction is executed by the server sequentially.
The server performs the read command and sends back measurement results when it receives a dynamic lifting command from the client.

So far Proto-Quipper only comes with its own custom simulator written in Haskell, and
currently there is no mechanism available to run Proto-Quipper programs on
the state-of-the art simulators, especially the ones with dynamic lifting. As it turns out, the client-server architecture is flexible
enough for us to implement servers that are based on other third-party quantum simulators,
as long as these servers implement the QServer language.  

\subsection{Contributions}
In this paper, we extend the existing Proto-Quipper simulation architecture with
state-of-the-art quantum simulators from Cirq and Qiskit (Section \ref{sec:integration}).  
Although these simulators do not directly support dynamic lifting,
we are able to slightly extend
the simulators' capabilities to enable running Proto-Quipper
programs that use dynamic lifting.
We also build an OpenQasm converter for Proto-Quipper circuits,
which enable the circuits to be ran on existing quantum processors
and simulators (Section \ref{sec:openqasm}).
Finally, we optimize our simulator using instruction queuing and
show they significantly outperform
the existing custom simulator on our benchmarks (Section \ref{sec:benchmarks}).
Our work is available at: \href{https://github.com/ian-turner/pyqserver}
{https://github.com/ian-turner/pyqserver}.




\section{Integrating Third-Party Simulators}
\label{sec:integration}

\subsection{Available Simulators}

Dozens of state-of-the-art quantum computing simulation programs exist currently \cite{jamadagni2024benchmarking}.
They employ a variety of different simulation methods, including statevector simulation, tensor networks,
decision trees, etc.
For this project, we chose to work with statevector simulators, which model quantum computation using matrix-vector
multiplication.
We integrated the simulation capabilities of the Python-based quantum computing libraries Cirq and Qiskit, given that
they are the most commonly used and extensively developed libraries for quantum computing,
and both have multiple state-of-the-art simulation methods.

In Qiskit and Cirq, the programs that
generate quantum circuits are usually structured
by the following: they start with an array of qubits and bits
all initialized to the $\ket{0}$ state, then we apply a series of in-place operations on those qubits and bits, and then (usually)
measuring the entire qubit array at the end and returning the final qubit and bit states.
The operations applied can be either unitary quantum gates or measurement gates.
There is some support for higher-level programming constructs such as `if' and `while' statements,
where operations can be conditioned on previous measurement outcomes, which is called \textit{dynamic circuits} in Qiskit. 
But these features are still experimental and are quite limited, so we do not use them in this project.


\subsection{Integration with Proto-Quipper}
\begin{figure*}
\centering
\resizebox{\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw [ rounded corners = 4.8, align=left] (6.25,15) rectangle  node[align=center] {Proto-Quipper \\ Interpreter} (10.25,10.25);
\draw [ rounded corners = 4.8] (16.25,15) rectangle  node {\LARGE Server} (20.25,10.25);
\draw [->, >=Stealth] (16.25,11.5) -- (10.25,11.5);
\node [font=\LARGE] at (13.25,15) {Commands};
\node [font=\LARGE] at (13.25,12) {Dynamic Lifting};
\draw [ rounded corners = 4.8] (16.5,11.5) rectangle  node {\normalsize Internal State} (20,10.5);


\draw [ rounded corners = 4.8] (1,13.25) rectangle  node {\normalsize Source Code} (5,12);
\draw [->, >=Stealth] (5,12.75) -- (6.25,12.75);
\draw [ rounded corners = 4.8] (21.25,14) rectangle  node {\large OpenQASM} (24.25,12.75);
\draw [->, >=Stealth] (20.25,13.5) -- (21.25,13.5);
\draw [ rounded corners = 4.8] (25.75,14) rectangle  node {\large Cirq} (28.5,12.75);
\draw [ rounded corners = 4.8] (25.75,12.25) rectangle  node {\large Qiskit} (28.5,11);
\draw [->, >=Stealth] (24.25,13.5) -- (25.75,13.5);
\draw [->, >=Stealth] (24.25,13.25) -- (25.75,11.75);
\draw [ rounded corners = 4.8] (11.5,14.5) rectangle  node {\large QServer language} (15,13.25);
\draw [->, >=Stealth] (10.25,14) -- (11.5,14);
\draw [->, >=Stealth] (15,14) -- (16.25,14);
\draw [ rounded corners = 4.8] (21.25,12.25) rectangle  node {\large State, Results} (24.25,11);
\draw [->, >=Stealth] (21.25,11.75) -- (20.25,11.75);
\draw [->, >=Stealth] (25.75,13.25) -- (24.25,11.75);
\draw [->, >=Stealth] (25.75,11.5) -- (24.25,11.5);
\end{circuitikz}
}%

\caption{Full OpenQASM-based simulation architecture}
\label{fig:full_sim_diagram}
\end{figure*}

The main challenges of integrating Cirq and Qiskit into the Proto-Quipper simulation infrastructure are
(1) Cirq and Qiskit do not allow dynamic qubit allocation; meaning ancilla qubits must be allocated during circuit generation,
(2) since Cirq and Qiskit both use the quantum circuit model, a circuit object must be constructed for every simulation,
even if that `circuit' is only a single gate, and (3) in Proto-Quipper, measurement operations `consume' a qubit
and convert it into a bit, while in Cirq and Qiskit measurements simply collapse the qubit into a classical state,
and copy the measurement result onto a separate bit register.

In order to integrate Cirq and Qiskit with Proto-Quipper, we must translate the QServer language
generated by the Proto-Quipper interpreter to the quantum circuit objects of the two libraries.
We chose to use OpenQASM as an intermediate representation, since both Cirq and Qiskit have OpenQASM loading functions,
which transform OpenQASM code into the circuit objects.
The QServer language is very similar to OpenQASM in its function and syntax, making translation
between the two very simple.
A diagram of the full OpenQASM simulation architecture is pictured in Figure \ref{fig:full_sim_diagram}.


\subsection{Simulation with Qiskit}

\begin{figure}
\centering

\begin{lstlisting}[language=Python,basicstyle=\small\ttfamily]
qc = QuantumCircuit(4)
qc.initialize(phi, [1, 2, 3])
qc.x(0)
result = sim.run(qc).result()
updated_state = result.get_statevector()
\end{lstlisting}
\resizebox{0.4\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw  (6.75,19.25) rectangle  node {\LARGE $|\psi\rangle$} (8.75,17.25);
\draw  (7.35,20.1) rectangle  node {\LARGE X} (8.1,19.4);
\draw [short] (4.75,19) -- (6.75,19);
\draw [short] (4.75,18.25) -- (6.75,18.25);
\draw [short] (4.75,17.5) -- (6.75,17.5);
\node [font=\Large] at (4.25,19) {$|0\rangle$};
\node [font=\Large] at (4.25,18.25) {$|0\rangle$};
\node [font=\Large] at (4.25,17.5) {$|0\rangle$};
\draw [short] (8.75,19) -- (10.75,19);
\draw [short] (8.75,18.25) -- (10.75,18.25);
\draw [short] (8.75,17.5) -- (10.75,17.5);
\draw [short] (4.75,19.75) -- (7.35,19.75);
\draw [short] (8.1,19.75) -- (10.75,19.75);
\node [font=\Large] at (4.25,19.75) {$|0\rangle$};
\node [font=\Large] at (11.75,18.5) {$|1\rangle \otimes |\psi\rangle$};
\end{circuitikz}
}%

\caption{Example of new qubit initialization in state $|1\rangle$ with existing state $|\psi\rangle$
	using Qiskit in Python. Here $\ket{\psi}$ is a three-qubit state, and the resulting output state is the four-qubit state
    $\ket{1} \otimes \ket{\psi}$.}
\label{fig:qubit_init}
\end{figure}

The QServer language contains three types of quantum operations: qubit initialization, unitary gates, and qubit measurement.
More importantly, it also has the `read' instruction, which lifts a bit from the server internal state back into the interpreter environment
to be used in further circuit generation.
When the server receives a read instruction, it must pause simulation and hold the current simulation state in memory,
send the measurement result back to the client, and wait for further instructions to continue the simulation.


\begin{figure*}
	\centering
	\begin{subfigure}{0.48\textwidth}
		\centering
\begin{lstlisting}[language=Haskell,basicstyle=\small\ttfamily]
bell00 : !(Unit ->
  Qubit * Qubit)
bell00 x =
  let
    a = H (Init0 ())
	b = Init0 ()
	(b, a) = CNot b a
  in (a, b)

main : Bool * Bool
main =
  let
    (a, b) = bell00 ()
  in (dynlift (Meas a),
    dynlift (Meas b))
\end{lstlisting}
		\caption{Proto-Quipper code}
	\end{subfigure}
	\begin{subfigure}{0.48\textwidth}
		\centering
\begin{lstlisting}[language=C,basicstyle=\small\ttfamily]
Q 0
H 0
Q 1
CNOT 1 0
M 0
R 0
M 1
R 1
\end{lstlisting}
		\caption{QServer code}
	\end{subfigure}
	\begin{subfigure}{0.5\textwidth}
		\centering
		\begin{lstlisting}[language=C,basicstyle=\small\ttfamily]
qubit[2] qs;
bit[2] bs;
h qs[0];
cx qs[0], qs[1];
bs[0] = measure qs[0];
bs[1] = measure qs[1];
\end{lstlisting}
		\caption{OpenQASM code}
	\end{subfigure}
	\caption{Comparison of code between Proto-Quipper, QServer and OpenQASM}
	\label{fig:code_comparison}
\end{figure*}

\paragraph{Qubit Initialization}

Qubits can be initialized into either the $|0\rangle$ or the $|1\rangle$ states.
If the simulation currently has the state $|\psi\rangle$, then when a new qubit
is added in state $|0\rangle$, the new simulation state will be $|0\rangle \otimes |\psi\rangle$.
This is pictured in Figure \ref{fig:qubit_init}.
The process is the same for initializing a qubit in the 1 state, except an X gate is applied
to the initialized qubit, and the resulting state is $|1\rangle \otimes |\psi\rangle$.

\paragraph{Unitary Gates}

\begin{figure}
\centering



\begin{lstlisting}[language=Python,basicstyle=\small\ttfamily]
qc = QuantumCircuit(3)
qc.initialize(phi, [0, 1, 2])
qc.h(0)
result = sim.run(qc).result()
phi_updated = result.get_statevector()
\end{lstlisting}



\resizebox{0.4\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\large]
\draw  (6.75,19.25) rectangle  node {\LARGE $|\psi\rangle$} (8.75,17.25);
\draw [short] (6.25,19) -- (6.75,19);
\draw [short] (6.25,18.25) -- (6.75,18.25);
\draw [short] (6.25,17.5) -- (6.75,17.5);
\node [font=\Large] at (5.75,19) {$|0\rangle$};
\node [font=\Large] at (5.75,18.25) {$|0\rangle$};
\node [font=\Large] at (5.75,17.5) {$|0\rangle$};
\draw [short] (8.75,19) -- (10.5,19);
\draw [short] (8.75,18.25) -- (12.75,18.25);
\draw [short] (8.75,17.5) -- (12.75,17.5);
\node [font=\LARGE] at (13.5,18.25) {$|\psi'\rangle$};
\draw  (10.5,19.25) rectangle  node {\large H} (11,18.75);
\draw [short] (11,19) -- (12.75,19);
\end{circuitikz}
}%

\caption{Application of a unitary H gate on qubit 1 of state $|\psi\rangle$ to produce updated state $|\psi'\rangle$}
\label{fig:unitary_gate}
\end{figure}

\begin{figure}
\centering


    \centering
    \begin{lstlisting}[language=Python,basicstyle=\small\ttfamily]
    b, phi_updated = phi.measure([0])
    phi.remove([0])
    \end{lstlisting}


    \centering

    \resizebox{0.3\textwidth}{!}{%
    \begin{circuitikz}
    \tikzstyle{every node}=[font=\LARGE]
    \draw  (7.75,14.5) rectangle  node {\LARGE $|\psi\rangle$} (9,13.25);
    \draw [short] (7.25,14.25) -- (7.75,14.25);
    \draw [short] (7.25,13.5) -- (7.75,13.5);
    \node [font=\Large] at (6.75,14.25) {$|0\rangle$};
    \node [font=\Large] at (6.75,13.5) {$|0\rangle$};
    \node [font=\Large] at (11.75,13.5) {$|\psi'\rangle$};
    \node [font=\Large] at (11.75,14.25) {$b$};
    \draw  (10.0,14.5) rectangle  node {\large M} (10.5,14.0);
    \draw [short] (9,13.5) -- (11.25,13.5);
    \draw [short] (9,14.25) -- (10.0,14.25);
    \draw [short] (10.5,14.3) -- (11.25,14.3);
    \draw [short] (10.5,14.2) -- (11.25,14.2);
    \end{circuitikz}
    }%

\caption{Python-like psuedo-code for measuring a qubit. The `remove' function here is a placeholder
for manual manipulation of the statevector using numpy.}



\label{fig:measure_circ}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{{ ./images/qft.png }}
\caption{Simulation time of QFT for all simulation methods. Here `direct' refers
to implementing and running the circuits directly in Qiskit/Cirq, without Proto-Quipper.}
\label{fig:qft}
\end{figure}


\begin{figure*}
\centering
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{{ ./images/qftadder.png }}
    \caption{QFT adder}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{{ ./images/cuccaro.png }}
    \caption{Cuccaro adder} 
\end{subfigure}
\hfill
\begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{{ ./images/gidney.png }}
    \caption{Gidney adder} 
\end{subfigure}
\caption{Simulation results for binary adders}
\label{fig:adder_results}
\end{figure*}


\begin{figure*}
    \centering
    \includegraphics[width=0.8\linewidth]{{ ./images/v3.png }}
    \caption{V3 circuit} 
    \label{fig:v3_bench}
\end{figure*}


\begin{figure}
\centering


\begin{subfigure}{0.4\textwidth}
    \centering
    \begin{lstlisting}[language=Python,basicstyle=\small\ttfamily]
# Inst 1: initialize qubit
qc = QuantumCircuit(3)
qc.initialize(phi, [1, 2])
result = sim.run(qc).result()
phi = result.get_statevector()

# Inst 2: initialize qubit
qc = QuantumCircuit(4)
qc.initialize(phi, [1, 2, 3])
result = sim.run(qc).result()
phi = result.get_statevector()

# Inst 3: H gate on qubit 2
qc = QuantumCircuit(4)
qc.initialize(phi, [0, 1, 2, 3])
qc.h(2)
result = sim.run(qc).result()
phi = result.get_statevector()

# Insts 4-6: gate instructions
# ...
    \end{lstlisting}

\caption{Unqueued execution of circuit in Qiskit.
Here each instruction requires a new circuit to be created and
run through the simulator.}
\end{subfigure}

\begin{subfigure}{0.4\textwidth}
    \centering
    \begin{lstlisting}[language=Python,basicstyle=\small\ttfamily]
# Run all instructions
qc = QuantumCircuit(4)
qc.initialize(phi, [2, 3])
qc.h(2)
qc.s(3)
qc.cx(2, 1)
qc.cx(1, 3)
res = sim.run(qc).result()
phi_n = res.get_statevector()
    \end{lstlisting}

    \resizebox{0.8\textwidth}{!}{%
    \begin{circuitikz}
    \tikzstyle{every node}=[font=\LARGE]
    \draw  (7.75,14.5) rectangle  node {\LARGE $|\psi\rangle$} (9,13.25);
    \draw [short] (7.25,14.25) -- (7.75,14.25);
    \draw [short] (7.25,13.5) -- (7.75,13.5);
    \node [font=\Large] at (6.75,14.25) {$|0\rangle$};
    \node [font=\Large] at (6.75,13.5) {$|0\rangle$};
    \node [font=\LARGE] at (13.5,14.5) {$|\psi'\rangle$};
    \draw  (9.5,14.5) rectangle  node {\large H} (10,14);
    \draw [short] (9,14.25) -- (9.5,14.25);
    \draw [short] (9,13.5) -- (10.25,13.5);
    \node [font=\Large] at (6.75,15.75) {$|0\rangle$};
    \node [font=\Large] at (6.75,15) {$|0\rangle$};
    \draw [short] (7.25,15) -- (12.75,15);
    \draw [short] (7.25,15.75) -- (12.75,15.75);
    \draw  (10.25,13.75) rectangle  node {\large S} (10.75,13.25);
    \node [font=\LARGE] at (9.75,13.75) {};
    \draw [short] (10,14.25) -- (12.75,14.25);
    \draw [short] (10.75,13.5) -- (12.75,13.5);
    \draw [short] (11.25,15.875) -- (11.25,14.15);
    \draw [ fill={rgb,255:red,0; green,0; blue,0} ] (11.25,14.25) circle (0.1cm);
    \draw  (11.25,15.75) circle (0.125cm);
    \draw [short] (12.25,15.1) -- (12.25,13.375);
    \draw [ fill={rgb,255:red,0; green,0; blue,0} ] (12.25,15) circle (0.1cm);
    \draw  (12.25,13.5) circle (0.125cm);
    \end{circuitikz}
    }%
    \caption{Queued circuit with initialization of a statevector $|\psi\rangle$ on qubits 3 and 4,
    initialization of qubits 1 and 2 in the $|0\rangle$ state, and several queued unitary gates,
    resulting in an updated state $|\psi'\rangle$.}
\end{subfigure}

\caption{Comparison between queued and un-queued circuits}
\label{fig:queued_circ}
\end{figure}

Unitary gates can be applied in a similar manner to initialization.
The current simulation state $|\psi\rangle$ is passed in using a state preparation gate,
and unitary gates are applied to the qubits.
The updated state $|\psi'\rangle$ is then extracted from the simulation results as a statevector,
and stored in memory for use in future computations.
An example of this is pictured in Figure \ref{fig:unitary_gate}.
\paragraph{Measurements}

Measurements can be performed directly on the statevector without creating circuit objects.
Both Qiskit and Cirq provide built-in functions for measurement, which take in a statevector
and a qubit index and return the collapsed statevector and measurement result.
Since measurements in Proto-Quipper consume the qubit, we must also remove the measured
qubit from the updated statevector returned from the measure function.
This can be done by manual manipulations of the statevector using numpy.
The generalized code for implementing measurements is given in Figure \ref{fig:measure_circ}.


\subsection{Instruction Queuing}


Given the fact that the server only sends back results when a read command is received, instructions need not be evaluated
until their results are required by the client.
This fact allows us to keep instructions in a queue, and only evaluate the accumulated
circuit once a measurement command is received.
This approach has several advantages.
First, the statevector of the previous computations only has to be prepared once, at the beginning of the
queued circuit, instead of between each instruction.
Second, it allows the simulator server to take advantage of optimizations in the Cirq and Qiskit simulators, which rely
on circuit re-writing and gate fusion \cite{elsman2025gate}.
An example of instruction queueing is given in Figure \ref{fig:queued_circ}.



\subsection{Converting to OpenQASM}

OpenQASM is used as an intermediate representation between the QServer language and the quantum simulators.
Commands are parsed as they are received over the socket connection with the client, and, if the simulator is
set to queuing mode, then non-measurement commands are placed into a queue.
When a measurement command is received, the parsed commands in the queue are then converted into OpenQASM
code using simple pattern matching, and the resulting code is input into the simulators, either Qiskit or Cirq.
A comparison of code representing a Bell state prep circuit in both Proto-Quipper, QServer, and OpenQASM is
given in Figure \ref{fig:code_comparison}.
While the Proto-Quipper code is longer and more complicated that the other two, Proto-Quipper provides
type checking and higher-level constructions that these other two languages do not, allowing for
more sophisticated circuit design at a higher level of abstraction.
This dynamic is analagous to how classical languages such as Python or Java compile higher-level code
to a low-level virtual machine language, and then that language is executed on the virtual machine.


\section{Benchmark Results}

In order to evaluate the simulator we construct a series of benchmark programs in Proto-Quipper.
These benchmarks include the quantum Fourier transform (QFT), several different implementations of binary adders,
multi-qubit teleportation, an example of a circuit using `repeat-until-success' gates,
and the MaxCut QAOA algorithm \cite{farhi2014quantum}.
We compare the queued and non-queued (normal) versions of the updated server against the original Haskell-based server.
We also compile the benchmark circuits to OpenQASM and run them directly on the Cirq and Qiskit simulators using Python.

\paragraph{Quantum Fourier Transform} The results for QFT (Figure \ref{fig:qft}) show that the queued versions of the Cirq and
Qiskit simulator significantly outperform
the original Haskell simulator as the number of qubits increases.
The Haskell simulator crashes when trying to simulate more than 20 qubits, while the Qiskit and Cirq simulators are able
to simulate 28 qubits.
They also show that while there is some overhead associated with the interaction of the Proto-Quipper interpreter with the server,
this overhead is almost constant as the circuit increases in size, and the simulation time of the server almost converges to the
simulation time of the bare simulator at around 25 qubits.


\paragraph{Binary Adders}


The Cirq and Qiskit simulators perform significantly worse than the Haskell simulator for binary adders,
as shown in Figure \ref{fig:adder_results}.
This is likely due to how the Haskell simulator stores quantum states.
The Haskell simulator stores the statevector as a map of bitstrings to amplitudes.
For example, the state $(|00\rangle + |11\rangle)/\sqrt{2}$ is stored as $[(00, 1/\sqrt{2}), (11, 1/\sqrt{2})]$.
This means that if the statevector is not in a superposition, then the Haskell representation needs
only one complex number to describe it.
This is in contrast to the Cirq and Qiskit simulators, which store the entire statevector, with $2^n$ entries (for $n$ qubits).
As a result, the Haskell simulator will almost always outperform the Cirq and Qiskit simulators on circuits that involve
mostly classical operations, such as adders.
Of course, useful quantum algorithms will inevitably contain many non-classical operations, resulting in a large degree
of superposition and entanglement, so in practice this limitation is largely irrelevant.


\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{{ ./images/maxcut.png }}
\caption{MaxCut QAOA}
\label{fig:maxcut}
\end{figure}


\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{{ ./images/tele.png }}
\caption{$n$-Qubit teleportation}
\label{fig:tele}
\end{figure}


\paragraph{MaxCut QAOA}

The maxcut quantum approximate optimization algorithm finds the partition of a graph into two graphs such that the
number of edges between the partitions (which are `cut') is maximized.
This circuit is an ideal candidate for a simulation benchmark since it is one of the few algorithms that may provide
quantum advantage in the near term, meaning quantum computers may soon be able to out-perform classical computers on this task.
Because of this, it has been the subject of much study and development, which requires accurate and fast simulation.
The results in Figure \ref{fig:maxcut} show that the Cirq and Qiskit simulators dramatically outperform the Haskell
simulator on this task.
This is not surprising, since the maxcut circuit creates states with high levels of superposition and entanglement.


\paragraph{Multi-Qubit Teleportation}

Quantum teleportation is a core concept in quantum computing.
It allows the transportation of qubit information from one physical qubit to another.
Teleportation has many practical uses, including quantum cryptography \cite{pirandola2015advances}, for example.
In this paper, we use \textit{multi-qubit} teleportation, which simply repeats teleportation $n$ times across $n$ qubits,
in order to show the scaling differences between simulators as the number of qubits increases.
The results are presented in Figure \ref{fig:tele}.


\paragraph{Repeat-Until Success}

`Repeat-until-success' (RUS) circuits are non-deterministic decompositions of unitary gates \cite{paetznick2013repeat}.
These circuits prepare a set of ancilla qubits in some initial state, then perform a unitary
operation involving both the ancillas and target qubits.
Then, the ancillas are measured for some terminal condition, e.g. `all ancillas are 0'.
If the terminal condition is reached, the operation has been performed.
Otherwise, the operation has failed, meaning the identity has been performed, and the entire
circuit is repeated until the terminal condition is reached.
These circuits provide an excellent benchmark for simulating dynamic lifting,
since they contain many mid-circuit measurements.
We choose the `V3' gate from the original RUS paper,
and construct an arbitrary circuit structure involving the preparation of all qubits
in the $\ket{+}$ state, $n$ V3 gates on the $n$ qubits,
followed by a layer of $n-1$ CNOT gates, where the control of the $i$-th gate
is on qubit $i$, and the target is on qubit $i+1$.
The results for this benchmark are presented in Figure \ref{fig:v3_bench}.


\section{Related work}

Other works have explored converting high-level quantum programming languages to OpenQASM in order to execute them more efficiently.
LinguaQuanta \cite{wesley2024linguaquanta} converts Quipper circuit objects to OpenQASM,
but only supports `boxed' circuits (which have no dynamic lifting instructions).
The Q\# language is a similar high-level language,
but is simulated by first compiling to quantum intermediate representation (QIR) \cite{stade2024towards},
a low-level quantum-classical hybrid specification based on LLVM.
Silq, another high-level language, runs on its own custom simulator,
and cannot be run on third-party simulators or any real quantum hardware.

While Cirq and Qiskit do allow creation and simulation of dynamic circuits, their capabilities are somewhat limited.
Both allow for `classically-controlled' gates, where measurement outcomes determine whether a specific gate
is applied or not.
Both also support `while' loops, where a section of the circuit is run until a specific boolean
outcome is achieved, e.g. $x \wedge y$ or $x \oplus y$, where $x$ and $y$ are measurement outcomes.
However, neither support dynamic qubit allocation and addressing, meaning all qubits must be initialized
at the start of the circuit, and the target qubits of a gate must be known at circuit generation time.
They also do not allow the seamless interleaving of circuit generation and execution, since circuits are generated
as Python objects, then handed off to the simulator, and a new circuit cannot be generated until the entire
simulation of the first circuit is finished.
This is contrast to Proto-Quipper, where a programmer can run a circuit simply by evaluating its expression,
and let the interpreter determine how best to simulate it, as well as influence the generation of a circuit during simulation time.


\section{Conclusion and Future Work}

This work presents an approach for simulating a high-level quantum programming language on state-of-the-art third-party
quantum simulators.
This approach extends the number of qubits able to be simulated compared to the existing Proto-Quipper simulator,
but has some downsides when compared to the original simulator, and is still significantly limited by memory constraints.
Future work could include integrating more advanced simulators such as tensor network simulators \cite{berezutskii2025tensor},
which can scale simulations to several hundred qubits by exploiting approximation and low degrees of entanglement.
Future work could also include compiling Proto-Quipper source code directly to a low-level intermediate format.


\bibliographystyle{splncs04}
\bibliography{refs}


\end{document}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: t
%%% End:
