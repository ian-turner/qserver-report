\documentclass[letterpaper]{article}
% DO NOT CHANGE THIS
\usepackage[]{aaai25} % DO NOT CHANGE THIS
\usepackage{times} % DO NOT CHANGE THIS
\usepackage{helvet} % DO NOT CHANGE THIS
\usepackage{courier} % DO NOT CHANGE THIS
\usepackage[hyphens]{url} % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm} % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\usepackage{natbib} % DO NOT CHANGE THIS
\usepackage{caption} % DO NOT CHANGE THIS
\frenchspacing % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in} % DO NOT CHANGE THISvb
\setlength{\pdfpageheight}{11in} % DO NOT CHANGE THIS
%
% Keep the \pdfinfo as shown here. Thereâ€™s no need
% for you to add the /Title and /Author tags.
\pdfinfo{
/TemplateVersion (2025.1)
}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{booktabs}
\usepackage{nicematrix}
\usepackage{tikz}
\usepackage{circuitikz}

%% Section numbering
\setcounter{secnumdepth}{2}


\title{Efficient Simulation of Proto-Quipper Programs}

\author{Ian Turner\textsuperscript{\rm 1}
}
\affiliations{

\textsuperscript{\rm 1}Department of Computer Science and
Engineering, University of South Carolina, Columbia, South Carolina, USA
}


\begin{document}

\maketitle



\begin{abstract}
    The Proto-Quipper language allows for high-level specification
    of quantum algorithms in a functional paradigm similar to Haskell.
    So far, the execution of Proto-Quipper programs has been confined
    to its own custom simulator (written in Haskell),
    with no ability to run on third-party
    simulators or real quantum hardware.
    This paper discusses efforts to integrate third-party locally-run
    simulators such as those developed by Google (Cirq) and IBM (Qiskit),
    as well as possible future efforts to enable execution of
    Proto-Quipper programs on cloud simulators and even 
    real quantum processing units (QPUs).
\end{abstract}



\section{Introduction}


\subsection{Quantum Programming Languages}

Quantum programming languages allow programers to design quantum algorithms at varying levels of abstraction.
`Low-level' languages like Cirq \cite{cirq}, Qiskit \cite{qiskit}, and OpenQASM \cite{cross2022openqasm} allow for
fine-grained control over circuit construction and execution, while
`high-level' languages such as Silq \cite{bichsel2020silq}, Q\# \cite{svore2018q}, Quipper \cite{green2013quipper},
 and Proto-Quipper \cite{fu2023proto}
allow for more complex circuits to be generated by using programming constructs like loops, recursion, and dynamic
qubit allocation.


\subsection{Proto-Quipper with Dynamic Lifting}

Proto-Quipper is a family of functional quantum programming languages designed to give a formal foundation to Quipper.
In contrast to low-level languages, Proto-Quipper contains two runtimes; circuit generation and circuit execution.
Variables whose values are defined during circuit generation time are called \textit{parameters}, while variables
that are defined during circuit execution time are called \textit{states}.
Dynamic lifting allows for state variables to be `lifted' to parameters variables.
This can be used to lift circuit measurement results from the circuit execution runtime back into the circuit
generation runtime in order to modify the generation of the next circuit.
This allows for quantum and classical instructions to be interleaved seamlessly.

Proto-Quipper also enforces a typing system, which ensures program correctness through type checking.
The types \textbf{Qubit} and \textbf{Bit} are considered \textit{linear}, meaning they cannot be duplicated
or discarded.
This prevents runtime/logic errors that can occur in low-level languages such as attempting to duplicate a qubit
or discarding a qubit without measuring it.


\subsection{Simulating Proto-Quipper Programs}

\begin{figure}[!ht]
\centering
\resizebox{0.4\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw [ rounded corners = 4.8] (6.25,15) rectangle  node {\LARGE Client} (10.25,10.25);
\draw [ rounded corners = 4.8] (16.25,15) rectangle  node {\LARGE Server} (20.25,10.25);
\draw [->, >=Stealth] (10.25,14) -- (16.25,14);
\draw [->, >=Stealth] (16.25,11.5) -- (10.25,11.5);
\node [font=\LARGE] at (13.25,14.5) {Commands};
\node [font=\LARGE] at (13.25,12) {Dynamic Lifting};
%%\draw [ rounded corners = 4.8] (16.5,11.5) rectangle  node {\normalsize Internal Quantum State} (20,10.5);
\end{circuitikz}
}%

\caption{Proto-Quipper simulation architecture}
\label{fig:sim_diagram}
\end{figure}


Proto-Quipper programs are simulated with a client-server architecture.
The Proto-Quipper interpreter parses high-level code into quantum
instructions in the server language, which is an assembly-like language
similar to OpenQASM.
The server language instructions are then sent over a network socket,
and each instruction is executed by the server sequentially.
The server sends back measurement results only when it receives a dynamic lifting command.
This process is shown in figure \ref{fig:sim_diagram}.



\section{Integrating Third-Party Simulators}


\begin{figure*}[!ht]
\centering
\resizebox{1\textwidth}{!}{%
\begin{circuitikz}
\tikzstyle{every node}=[font=\LARGE]
\draw [ rounded corners = 4.8] (6.25,15) rectangle  node {\LARGE Interpreter} (10.25,10.25);
\draw [ rounded corners = 4.8] (16.25,15) rectangle  node {\LARGE Server} (20.25,10.25);
\draw [->, >=Stealth] (16.25,11.5) -- (10.25,11.5);
\node [font=\LARGE] at (13.25,15) {Commands};
\node [font=\LARGE] at (13.25,12) {Dynamic Lifting};
\draw [ rounded corners = 4.8] (16.5,11.5) rectangle  node {\normalsize Internal Quantum State} (20,10.5);


\draw [ rounded corners = 4.8] (1,13.25) rectangle  node {\large Proto-Quipper code} (5,12);
\draw [->, >=Stealth] (5,12.75) -- (6.25,12.75);
\draw [ rounded corners = 4.8] (21.25,14) rectangle  node {\large OpenQASM} (24.25,12.75);
\draw [->, >=Stealth] (20.25,13.5) -- (21.25,13.5);
\draw [ rounded corners = 4.8] (25.75,14) rectangle  node {\large Cirq} (28.5,12.75);
\draw [ rounded corners = 4.8] (25.75,12.25) rectangle  node {\large Qiskit} (28.5,11);
\draw [->, >=Stealth] (24.25,13.5) -- (25.75,13.5);
\draw [->, >=Stealth] (24.25,13.5) -- (25.75,11.75);
\draw [ rounded corners = 4.8] (11.5,14.5) rectangle  node {\large Server language} (15,13.25);
\draw [->, >=Stealth] (10.25,14) -- (11.5,14);
\draw [->, >=Stealth] (15,14) -- (16.25,14);
\draw [ rounded corners = 4.8] (21.25,12.25) rectangle  node {\large Results} (24.25,11);
\draw [->, >=Stealth] (21.25,11.75) -- (20.25,11.75);
\draw [->, >=Stealth] (25.75,13.25) -- (24.25,11.75);
\draw [->, >=Stealth] (25.75,11.5) -- (24.25,11.5);
\end{circuitikz}
}%

\label{fig:full_sim_diagram}
\caption{Full OpenQASM-based simulation architecture}
\end{figure*}


\subsection{Existing Simulators}

Dozens of state-of-the-art quantum computing simulation programs exist currently \cite{jamadagni2024benchmarking}.
They employ a variety of different simulation methods, including statevector simulation, tensor networks,
decision trees, etc.
For this project, we chose to work with statevector simulators, which model quantum computation using matrix-vector
multiplication.
We integrated the simulation capabilities of the Python-based quantum computing libraries Cirq and Qiskit, given that
they are the most commonly used and extensively developed libraries for QC,
and both have multiple state-of-the-art simulation methods.

Both Qiskit and Cirq use the quantum circuit model to represent quantum circuits.
In the quantum circuit model, a computation is carried out by starting with an array of qubits and bits
all initialized to the 0 state, applying a series of in-place operations on those qubits and bits, and then (usually)
measuring the entire qubit array at the end and returning the final qubit and bit states.
The operations applied can be either unitary quantum gates or measurement gates.
There is some support for higher-level programming constructs such as `if' and `while' statements,
where operations can be conditioned on previous measurement outcomes,
but these features are still experimental and are quite limited, so we do not use them in this project.


\subsection{Integration with Proto-Quipper}

The main challenges of integrating Cirq and Qiskit into the Proto-Quipper simulation infrastructure are
(1) Cirq and Qiskit do not allow dynamic qubit allocation; meaning ancilla qubits must be allocated during circuit generation,
(2) since Cirq and Qiskit both use the quantum circuit model, a circuit object must be constructed for every simulation,
even if that `circuit' is only a single gate, and (3) in Proto-Quipper, measurement operations `consume' a qubit
and convert it into a bit, while in Cirq and Qiskit measurements simply collapse the qubit into a classical state,
and copy the measurement result onto a separate bit register.

In order to integrate Cirq and Qiskit with Proto-Quipper, a translation must be made between the server language
generated by the Proto-Quipper interpreter and the quantum circuit model of the two libraries.
We chose to use OpenQASM as an intermediate representation, since both Cirq and Qiskit have OpenQASM loading functions,
which transform OpenQASM code into the circuit objects of both libraries.
The original Proto-Quipper server language is also very similar to OpenQASM in its function and syntax, making translation
between the two very simple.


\subsection{Converting to OpenQASM}

The Proto-Quipper server language contains three types of instructions: qubit initialization, unitary gates, and qubit measurement.
Measurement outcomes can also be used as control bits of unitary gates to create `clasically-controlled' gates.


\subsection{Instruction Queuing}


\section{Benchmarks}

\section{Related work}

\section{Conclusion and Future Work}

\paragraph{Investigating MPS}
\paragraph{Dynamic lifting to OpenQasm3}
\paragraph{Dynamic lifting to QIR}



\bibliography{refs.bib}

\end{document}

