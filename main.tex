\documentclass[a4paper,11pt]{article}
\usepackage[margin=0.5in,bottom=1in]{geometry}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{authblk}
\usepackage{titling}
\bibliographystyle{plain}





\begin{document}

\title{
\textbf{
Efficient Simulation of Proto-Quipper Programs
}
}
\author{Ian Turner, University of South Carolina}
\predate{}
\date{}
\postdate{}
\maketitle



\begin{abstract}
    The Proto-Quipper language allows for high-level specification
    of quantum algorithms in a functional paradigm similar to Haskell.
    So far, the execution of Proto-Quipper programs has been confined
    to its own custom simulator (written in Haskell),
    with no ability to run on third-party
    simulators or real quantum hardware.
    This paper discusses efforts to integrate third-party locally-run
    simulators such as those developed by Google (Cirq) and IBM (Qiskit),
    as well as possible future efforts to enable execution of
    Proto-Quipper programs on cloud simulators and even 
    real quantum processing units (QPUs).
    We start by describing the technical requirements of Proto-Quipper
    program simulation,
    as well as the differences from other quantum programming
    paradigms that make interoperability between Proto-Quipper and
    rest of the quantum ecosystem difficult.
    We then explain our specific implementation of a new simulator
    architecture that allows for Proto-Quipper programs to be run
    on third-party simulators, and benchmark our implementation
    against the existing Haskell-based simulator on several
    quantum computing tasks.
    Finally, we discuss the shortcomings of our approach and how future
    work can overcome these, including the current lack of ability to
    run Proto-Quipper programs on currently available QPUs.
\end{abstract}



\section{Introduction}



\subsection{Quantum Programming Languages}

Quantum programming languages allow programmers to design quantum algorithms at varying levels of abstraction,
without having to specify the machine instructions required to implement the components of those algorithms.
These languages can broadly be broken down into `high-level' and `low-level'.
Low-level languages, such Cirq \cite{cirq}, Qiskit \cite{qiskit}, and OpenQASM \cite{cross2022openqasm}
can essentially be described as `circuit description languages', where programs are built as a series of unitary
gate applications to a set of input qubits, as well as mid-circuit measurement operations and gates conditioned on
those measurement results.
These languages, similar to assembly languages in classical computing, provide fine-grained control over hardware execution,
but lack flexibility.
Although these languages have recently started to add more higher-level programming constructs to their syntax
(such as for loops and classical variables), they still remain quite limited, mainly in their lack of ability
to dynamically allocate and de-allocate qubits `on the fly', meaning that the number of qubits a computation uses
must be known at compile time, and each gate must be mapped to a specific qubit index.
Cirq and Qiskit are also embedded languages with Python that lack their own syntax/interpreter and rely greatly
on Python programming constructs to extend their capabilities.


In contrast, high-level languages, such as Silq \cite{bichsel2020silq}, Q\# \cite{QSharpDocs},
and Proto-Quipper \cite{fu2023proto}, are much more flexible
and extensible, and are designed to generalize to any quantum hardware.
They allow for dynamic allocation and de-allocation of qubits, meaning circuits with `ancillas' (qubits that are allocated during
a circuit, used for computation, then returned to the zero state and de-allocated at the end of the circuit)
can be programmed easily and directly, without the programmer having to worry about qubit memory allocation at compile time.
They also allow for higher-level classical programming constructs like functions and loops, as well as quantum
programming constructs like uncomputation.


\subsection{Proto-Quipper with Dynamic Lifting}




\subsection{Simulation of Quantum Computing}




\subsection{Client-Server Architecture}


\subsection{OpenQasm}


\section{Interpreter for qserver language}


\subsection{Intro to the qserver language}

\subsection{An interpreter for the qserver language in Cirq}

\subsection{An interpreter for the qserver language in Qiskit}


\subsection{Some benchmark results}
QFT, QFT adders, Cucarro adders. 
Semi-classical QFT, Gidney's logical and adder. 
RUS-RZ gate. (Try magic state distillation, Try quantum error correction for surface code)
\section{Improving the efficiency of interpreter by queuing}

\subsection{Idea}

\subsection{Implementation details}

\subsection{Benchmark results for the improvement}

\section{Related work}
\subsection{Quipper circuits translation}

\subsection{Various simulators from Cirq and Qiskit}


\section{Conclusion and Future Work}

\paragraph{Investigating MPS}
\paragraph{Dynamic lifting to OpenQasm3}
\paragraph{Dynamic lifting to QIR}



\bibliography{refs}

\end{document}

